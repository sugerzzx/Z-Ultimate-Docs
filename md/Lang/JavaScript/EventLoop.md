# js 事件循环

## Event loops in the HTML standard

[To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.](https://html.spec.whatwg.org/multipage/webappapis.html#definitions-3)

> [!INFO] TRANS
> 为了协调事件、用户交互、脚本、渲染、网络等，用户代理必须使用本节所述的事件循环。每个代理都有一个关联的事件循环，该循环对于该代理是唯一的。

HTML 标准中关于事件循环的定义强调了用户代理（User Agent）必须使用事件循环来协调各种任务的执行，包括事件处理、用户交互、脚本执行、页面渲染、网络请求等等。具体来说，这段定义表明了以下几点：

1. **任务协调**：用户代理必须使用事件循环来协调各种任务的执行，以确保页面的各种行为按照预期进行。这些任务包括处理事件、响应用户交互、执行 JavaScript 脚本、渲染页面、处理网络请求等等。

2. **事件循环的必要性**：为了管理和调度这些任务，用户代理必须依赖事件循环机制。事件循环能够有效地处理异步任务，并且确保它们按照正确的顺序和时机执行。

3. **每个用户代理拥有独立的事件循环**：每个用户代理都有自己的事件循环，这个事件循环是唯一的，并且与其他用户代理的事件循环是独立的。这意味着每个用户代理都可以根据自身的需求和实现细节来管理任务的执行，而不会受到其他代理的影响。

HTML 标准中的事件循环定义强调了事件循环在 Web 浏览器中的重要性，以及用户代理必须使用事件循环来协调各种任务的执行，以确保页面的各种行为按照预期进行。

### task queues | 任务队列

_An event loop has one or more task queues. A task queue is a set of tasks._

事件循环包含一个或多个任务队列，每个队列中都有一组待执行的任务。
任务队列被描述为集合而不是队列，因为事件循环处理模型不是按照队列的方式处理任务。相反，它从所选队列中抓取第一个可运行的任务，而不是按照队列的顺序逐个出队任务。

_Tasks encapsulate algorithms that are responsible for such work as:_

任务封装了负责以下工作的算法：

1. **事件（Events）**：

   - 事件的分发（dispatching）通常由一个专用的任务完成。这意味着当事件发生时，例如点击事件、键盘事件等，浏览器会调用相应的事件处理程序，并将事件对象传递给它。
   - 并非所有事件都是通过任务队列分发的，许多事件在其他任务执行过程中分发。

2. **解析（Parsing）**：

   - HTML 解析器处理一或多个字节并解析出标记（tokens），然后处理任何生成的标记。这通常是一个任务，用于解析 HTML 内容并将其转换为 DOM 结构。

3. **回调（Callbacks）**：

   - 调用回调函数通常由一个专用的任务完成。例如，当定时器到期时，浏览器会调用相应的回调函数来执行定时器任务。

4. **资源使用（Using a resource）**：

   - 当算法获取资源时，如果获取是以非阻塞方式进行的，则一旦资源的一部分或全部可用，资源的处理就会由一个任务来执行。这通常涉及对获取的资源进行处理和使用。

5. **对 DOM 操作的响应（Reacting to DOM manipulation）**：
   - 一些元素具有在对 DOM 进行操作时触发的任务，例如将元素插入文档时。这些任务通常用于处理与 DOM 操作相关的工作，例如更新页面布局或触发其他事件。

综上所述，任务是浏览器中执行各种工作的算法的封装。它们负责处理事件分发、解析 HTML、调用回调函数、使用资源以及对 DOM 操作的响应等各种任务。

_Formally, a task is a struct which has:_

1. **任务的形式定义**：

   - 任务被形式化定义为一个结构，其中包含以下几个字段：
     - 步骤（Steps）：指定了任务要执行的工作的一系列步骤。
     - 来源（Source）：任务的来源，用于对相关任务进行分组和序列化。
     - 文档（Document）：与任务关联的文档对象，如果任务不在窗口事件循环中，则为 null。
     - 脚本评估环境设置对象集合（Script Evaluation Environment Settings Object Set）：用于跟踪任务执行期间的脚本评估环境设置的对象集合。
   - 可运行的任务是指其文档要么是 null，要么是完全活动的。

2. **任务源和任务队列的概念**：

   - 任务源用于在标准中区分逻辑上不同类型的任务，以便用户代理能够区分它们。
   - 任务队列由用户代理用于在给定的事件循环中汇总任务源。
   - 每个事件循环中的每个任务源必须与一个特定的任务队列关联。

3. **示例**：
   - 用户代理可以为鼠标和键盘事件分配一个任务队列，为其他任务源分配另一个任务队列。然后，用户代理可以根据事件循环处理模型的规定，在绝大多数时间内优先处理键盘和鼠标事件，以保持界面响应性，但不会让其他任务队列被饿死。这样的设置保证了用户代理永远不会以任何一种任务源的事件顺序处理事件。

综上所述，任务源和任务队列的概念有助于用户代理将不同类型的任务进行分组和处理，并且在事件循环中协调它们的执行，从而保证了整个系统的稳定性和性能。

### microtask queue | 微任务队列

_The microtask queue is not a task queue._

尽管微任务队列也包含一组待执行的任务，但它不是任务队列的一种形式。
微任务队列是一种特殊的队列，它在每个事件循环迭代的末尾被执行。微任务队列中的任务具有比任务队列中的任务更高的优先级，并且在执行完当前事件循环迭代中的所有宏任务后立即执行

## The Node.js Event Loop

[The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick#what-is-the-event-loop)

这句话解释了 Node.js 中事件循环（event loop）的作用以及 JavaScript 单线程特性下如何实现非阻塞 I/O 操作的原理。逐步解释：

1. **事件循环（event loop）**：事件循环是 Node.js 的核心机制之一，用于处理异步操作和事件驱动的编程范式。它负责接收和分发事件，并且在事件发生时执行相应的回调函数。

2. **JavaScript 的单线程特性**：JavaScript 是一种单线程语言，意味着它只有一个主线程来执行代码。在传统的同步编程模型中，当主线程执行 I/O 操作时会发生阻塞，直到操作完成才能继续执行后续代码。

3. **非阻塞 I/O 操作**：为了避免主线程的阻塞，Node.js 采用了非阻塞 I/O 操作。这意味着当主线程发起一个 I/O 操作（如文件读取、网络请求等）时，它不会等待操作完成，而是立即继续执行后续代码。

4. **操作系统内核的利用**：Node.js 通过将 I/O 操作委托给操作系统内核来实现非阻塞 I/O。操作系统内核负责管理系统资源，并且通常会提供一些**异步操作的 API**，允许程序发起 I/O 请求而无需等待操作完成。这样，当 Node.js 发起一个非阻塞 I/O 操作时，操作系统内核会在后台处理这个操作，同时允许 Node.js 主线程继续执行其他代码。

**综上所述**，事件循环是 Node.js 实现非阻塞 I/O 操作的关键机制之一。它允许 Node.js 主线程在执行 I/O 操作时不被阻塞，通过将操作委托给操作系统内核并利用操作系统提供的异步 API 来实现。这使得 Node.js 能够高效地处理大量并发的 I/O 操作，从而提高了应用程序的性能和吞吐量。

上述特性同样适用于浏览器中的 JavaScript。虽然浏览器和 Node.js 是不同的环境，但它们都采用了类似的事件驱动和异步编程模型，以处理 I/O 操作和其他异步任务。

在浏览器中，JavaScript 同样是单线程的，主要负责处理用户界面和执行 JavaScript 代码。然而，浏览器环境与 Node.js 不同，它还必须处理用户交互、渲染页面和网络请求等任务。

**因此**，浏览器中的 JavaScript 同样利用事件循环和非阻塞 I/O 操作来处理异步任务。例如，浏览器中的 Ajax 请求、DOM 事件处理、定时器等都是异步的，它们不会阻塞主线程的执行，而是通过事件循环和回调函数来处理。

### Event Loop 工作原理

逐步理解 Node.js 启动过程及其事件循环如何工作：

1. **初始化:** 当您启动 Node.js 应用程序时，它首先会初始化一些内部变量和设置，例如全局对象和模块系统。

2. **处理输入脚本:** 接下来，Node.js 会处理您提供的脚本文件。该脚本可能会包含同步和异步代码。

   - **同步代码:** 同步代码会一行一行地执行，直到完成。在此期间，事件循环会阻塞，不会处理任何其他任务。

   - **异步代码:** 异步代码不会阻塞事件循环。相反，它会将任务委托给其他线程 (例如，操作系统线程) 来处理，然后继续执行后续代码。当异步操作完成时，它会将结果放入事件队列中，通知事件循环进行处理。

3. **事件循环:** 处理完输入脚本后，Node.js 就进入了主循环，即事件循环。事件循环是一个不断运行的程序，它会一直执行以下操作，直到进程退出：

   - **检查事件队列:** 事件队列是一个存储待处理任务的列表。这些任务可能是来自完成的异步操作的回调函数，也可能是使用 `setTimeout` 或 `setInterval`之类的函数 schedulers 的计时器回调函数。

   - **处理队列中的任务:** 事件循环会依次处理队列中的任务，遵循先进先出 (FIFO) 的原则。对于每个任务，它都会调用相应的回调函数来执行相应的操作。

   - **非阻塞 I/O:** 当遇到需要等待外部操作 (例如，网络请求或文件读写) 的 I/O 操作时，Node.js 不会阻塞事件循环。相反，它会将该操作委托给操作系统，然后继续处理其他任务。一旦操作完成，操作系统会通知 Node.js，然后事件循环会将相应的回调函数放入事件队列中以供稍后处理。

   - **空闲阶段:** 如果事件队列为空，并且没有其他待处理的任务，事件循环会进入空闲阶段。在空闲阶段，事件循环会等待 I/O 事件或计时器超时事件的通知。

```
一个简化的事件循环操作顺序流程图
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

> 每个方块都被称为事件循环中的一个“**阶段**”

每个**阶段**都有一个遵循先进先出 (FIFO) 原则的**回调队列**。事件循环依次处理这些阶段，每个阶段都会先执行该阶段特有的操作，然后依次处理队列中的回调函数，直到队列为空或达到最大回调处理限制。一旦处理完该阶段的队列，事件循环就会进入下一个阶段，继续按照同样的方式执行。

#### 阶段概述

1. **timers（定时器）**：

   - 在这个阶段，执行由 `setTimeout()` 和 `setInterval()` 安排的回调函数。

2. **pending callbacks（挂起回调）**：

   - 在上一个循环迭代中被延迟到下一个循环迭代的 I/O 回调函数被执行。

3. **idle、prepare**：

   - 这两个阶段通常只在内部使用，不对用户代码可见。

4. **poll（轮询）**：

   - 在这个阶段，Node.js 会检索新的 I/O 事件。大多数 I/O 相关的回调函数（除了被定时器安排的、以及 `setImmediate()` 安排的）都会在这个阶段执行。
   - 当没有任何计划的定时器和 `setImmediate()` 回调时，Node.js 将在这里阻塞，等待事件的到来。

5. **check（检查）**：

   - `setImmediate()` 回调函数在这个阶段被调用。

6. **close callbacks（关闭回调）**：
   - 一些关闭事件的回调函数在这个阶段被执行，例如 `socket.on('close', ...)`。

#### 阶段详述

##### timers（定时器）

##### pending callbacks（挂起回调）

##### idle、prepare

##### poll（轮询）

##### check（检查）

##### close callbacks（关闭回调）

##### setImmediate 和 setTimeout

#### process.nextTick

1. **`process.nextTick()` 不是事件循环的一部分**：

   - 尽管 `process.nextTick()` 是异步 API 的一部分，但它并不是严格意义上事件循环的一部分。它是在事件循环的特定阶段之后执行的。

2. **`process.nextTick()` 的执行时机**：

   - 当调用 `process.nextTick()` 时，它的回调函数会在当前**操作**（transition）完成后立即执行，而不受事件循环当前阶段的影响。这个**操作**通常是从底层的 C/C++ 处理程序转换为执行所需的 JavaScript。

3. **`process.nextTick()` 的影响**：
   - 在给定的事件循环阶段中调用 `process.nextTick()` 时，所有传递给 `process.nextTick()` 的回调都会在事件循环继续之前解析。这可能会导致一些问题，因为它允许您通过递归调用 `process.nextTick()` 来“饿死”您的 I/O，这会阻止事件循环进入轮询阶段。

这段话的重点在于强调 `process.nextTick()` 的特殊性，以及它对事件循环执行流程的影响。通过理解这些概念，可以更好地优化和管理异步代码，避免可能导致性能问题的陷阱。
